<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JavaEncryptor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">EspaiEncrip</a> &gt; <a href="index.source.html" class="el_package">com.auteam.espaiencrip</a> &gt; <span class="el_source">JavaEncryptor.java</span></div><h1>JavaEncryptor.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.auteam.espaiencrip;

import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.Signature;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.owasp.esapi.ESAPI;
import org.owasp.esapi.EncoderConstants;
import org.owasp.esapi.Encryptor;
import org.owasp.esapi.Logger;
import org.owasp.esapi.codecs.Hex;
import org.owasp.esapi.crypto.CipherSpec;
import org.owasp.esapi.crypto.CipherText;
import org.owasp.esapi.crypto.CryptoHelper;
import org.owasp.esapi.crypto.KeyDerivationFunction;
import org.owasp.esapi.crypto.PlainText;
import org.owasp.esapi.crypto.SecurityProviderLoader;
import org.owasp.esapi.errors.ConfigurationException;
import org.owasp.esapi.errors.EncryptionException;
import org.owasp.esapi.errors.IntegrityException;



<span class="nc bnc" id="L51" title="All 2 branches missed.">public final class JavaEncryptor implements Encryptor {</span>
    private static volatile Encryptor singletonInstance;

    // Note: This double-check pattern only works because singletonInstance
    //       is declared to be volatile.  Usually this method is called
    //       via ESAPI.encryptor() rather than directly.
    public static Encryptor getInstance() throws EncryptionException {
<span class="nc bnc" id="L58" title="All 2 branches missed.">        if ( singletonInstance == null ) {</span>
<span class="nc" id="L59">            synchronized ( JavaEncryptor.class ) {</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">                if ( singletonInstance == null ) {</span>
<span class="nc" id="L61">                    singletonInstance = new JavaEncryptor();</span>
                }
<span class="nc" id="L63">            }</span>
        }
<span class="nc" id="L65">        return singletonInstance;</span>
    }

<span class="nc" id="L68">    private static boolean initialized = false;</span>
    
    // encryption
<span class="nc" id="L71">    private static SecretKeySpec secretKeySpec = null; // DISCUSS: Why static? Implies one key?!?</span>
<span class="nc" id="L72">    private static String encryptAlgorithm = &quot;AES&quot;;</span>
<span class="nc" id="L73">    private static String encoding = &quot;UTF-8&quot;; </span>
<span class="nc" id="L74">    private static int encryptionKeyLength = 128;</span>
    
    // digital signatures
<span class="nc" id="L77">    private static PrivateKey privateKey = null;</span>
<span class="nc" id="L78">	private static PublicKey publicKey = null;</span>
<span class="nc" id="L79">	private static String signatureAlgorithm = &quot;SHA1withDSA&quot;;</span>
<span class="nc" id="L80">    private static String randomAlgorithm = &quot;SHA1PRNG&quot;;</span>
<span class="nc" id="L81">	private static int signatureKeyLength = 1024;</span>
	
	// hashing
<span class="nc" id="L84">	private static String hashAlgorithm = &quot;SHA-512&quot;;</span>
<span class="nc" id="L85">	private static int hashIterations = 1024;</span>
	
	// Logging - DISCUSS: This &quot;sticks&quot; us with a specific logger to whatever it was when
	//					  this class is first loaded. Is this a big limitation? Since there
	//                    is no method to reset it, we may has well make it 'final' also.
<span class="nc" id="L90">	private static Logger logger = ESAPI.getLogger(&quot;JavaEncryptor&quot;);</span>
	    // Used to print out warnings about deprecated methods.
<span class="nc" id="L92">	private static int encryptCounter = 0;</span>
<span class="nc" id="L93">	private static int decryptCounter = 0;</span>
        // DISCUSS: OK to not have a property for this to set the frequency?
        //          The desire is to persuade people to move away from these
	    //          two deprecated encrypt(String) / decrypt(String) methods,
        //          so perhaps the annoyance factor of not being able to
        //          change it will help. For now, it is just hard-coded here.
        //          We could be mean and just print a warning *every* time.
	private static final int logEveryNthUse = 25;
	
    // *Only* use this string for user messages for EncryptionException when
    // decryption fails. This is to prevent information leakage that may be
    // valuable in various forms of ciphertext attacks, such as the
	// Padded Oracle attack described by Rizzo and Duong.
    private static final String DECRYPTION_FAILED =
        &quot;Decryption failed; see logs for details.&quot;;

    // # of seconds that all failed decryption attempts will take. Used to
    // help prevent side-channel timing attacks.
<span class="nc" id="L111">    private static int N_SECS = 2;</span>

	// Load the preferred JCE provider if one has been specified.
	static {
	    try {
<span class="nc" id="L116">            SecurityProviderLoader.loadESAPIPreferredJCEProvider();</span>
<span class="nc" id="L117">        } catch (NoSuchProviderException ex) {</span>
        	// Note that audit logging is done elsewhere in called method.
<span class="nc" id="L119">            logger.fatal(Logger.SECURITY_FAILURE,</span>
                         &quot;JavaEncryptor failed to load preferred JCE provider.&quot;, ex);
<span class="nc" id="L121">            throw new ExceptionInInitializerError(ex);</span>
<span class="nc" id="L122">        }</span>
<span class="nc" id="L123">        setupAlgorithms();</span>
<span class="nc" id="L124">	}</span>
	
    /**
     * Generates a new strongly random secret key and salt that can be
     * copy and pasted in the &lt;b&gt;ESAPI.properties&lt;/b&gt; file.
     * 
     * @param args Set first argument to &quot;-print&quot; to display available algorithms on standard output.
     * @throws java.lang.Exception	To cover a multitude of sins, mostly in configuring ESAPI.properties.
     */
    public static void main( String[] args ) throws Exception {
<span class="nc" id="L134">		System.out.println( &quot;Generating a new secret master key&quot; );</span>
		
		// print out available ciphers
<span class="nc bnc" id="L137" title="All 4 branches missed.">		if ( args.length == 1 &amp;&amp; args[0].equalsIgnoreCase(&quot;-print&quot; ) ) {</span>
<span class="nc" id="L138">			System.out.println( &quot;AVAILABLE ALGORITHMS&quot; );</span>

<span class="nc" id="L140">			Provider[] providers = Security.getProviders();</span>
<span class="nc" id="L141">			TreeMap&lt;String, String&gt; tm = new TreeMap&lt;String, String&gt;();</span>
			// DISCUSS: Note: We go through multiple providers, yet nowhere do I
			//			see where we print out the PROVIDER NAME. Not all providers
			//			will implement the same algorithms and some &quot;partner&quot; with
			//			whom we are exchanging different cryptographic messages may
			//			have _different_ providers in their java.security file. So
			//			it would be useful to know the provider name where each
			//			algorithm is implemented. Might be good to prepend the provider
			//			name to the 'key' with something like &quot;providerName: &quot;. Thoughts?
<span class="nc bnc" id="L150" title="All 2 branches missed.">			for (int i = 0; i != providers.length; i++) {</span>
				// DISCUSS: Print security provider name here???
					// Note: For some odd reason, Provider.keySet() returns
					//		 Set&lt;Object&gt; of the property keys (which are Strings)
					//		 contained in this provider, but Set&lt;String&gt; seems
					//		 more appropriate. But that's why we need the cast below.
<span class="nc" id="L156">	            System.out.println(&quot;===== Provider &quot; + i + &quot;:&quot; + providers[i].getName() + &quot; ======&quot;);</span>
<span class="nc" id="L157">				Iterator&lt;Object&gt; it = providers[i].keySet().iterator();</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">				while (it.hasNext()) {</span>
<span class="nc" id="L159">					String key = (String)it.next();</span>
<span class="nc" id="L160">		            String value = providers[i].getProperty( key );</span>
<span class="nc" id="L161">		            tm.put(key, value);</span>
<span class="nc" id="L162">	                System.out.println(&quot;\t\t   &quot; + key + &quot; -&gt; &quot;+ value );</span>
<span class="nc" id="L163">				}</span>
			}

<span class="nc" id="L166">			Set&lt; Map.Entry&lt;String,String&gt; &gt; keyValueSet = tm.entrySet();</span>
<span class="nc" id="L167">			Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = keyValueSet.iterator();</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">			while( it.hasNext() ) {</span>
<span class="nc" id="L169">				Map.Entry&lt;String,String&gt; entry = it.next();</span>
<span class="nc" id="L170">				String key = entry.getKey();</span>
<span class="nc" id="L171">				String value = entry.getValue();</span>
<span class="nc" id="L172">	        	System.out.println( &quot;   &quot; + key + &quot; -&gt; &quot;+ value );</span>
<span class="nc" id="L173">			}</span>
<span class="nc" id="L174">		} else {</span>
				// Used to print a similar line to use '-print' even when it was specified.
<span class="nc" id="L176">			System.out.println( &quot;\tuse '-print' to also show available crypto algorithms from all the security providers&quot; );</span>
		}
		
        // setup algorithms -- Each of these have defaults if not set, although
		//					   someone could set them to something invalid. If
		//					   so a suitable exception will be thrown and displayed.
<span class="nc" id="L182">                encryptAlgorithm = ESAPI.securityConfiguration().getEncryptionAlgorithm();</span>
<span class="nc" id="L183">                encryptionKeyLength = ESAPI.securityConfiguration().getEncryptionKeyLength();</span>
<span class="nc" id="L184">                randomAlgorithm = ESAPI.securityConfiguration().getRandomAlgorithm();</span>

<span class="nc" id="L186">		SecureRandom random = SecureRandom.getInstance(randomAlgorithm);</span>
<span class="nc" id="L187">		SecretKey secretKey = CryptoHelper.generateSecretKey(encryptAlgorithm, encryptionKeyLength);</span>
<span class="nc" id="L188">                byte[] raw = secretKey.getEncoded();</span>
<span class="nc" id="L189">                byte[] salt = new byte[20];	// Or 160-bits; big enough for SHA1, but not SHA-256 or SHA-512.</span>
<span class="nc" id="L190">                random.nextBytes( salt );</span>
<span class="nc" id="L191">                String eol = System.getProperty(&quot;line.separator&quot;, &quot;\n&quot;); // So it works on Windows too.</span>
<span class="nc" id="L192">                System.out.println( eol + &quot;Copy and paste these lines into your ESAPI.properties&quot; + eol);</span>
<span class="nc" id="L193">                System.out.println( &quot;#==============================================================&quot;);</span>
<span class="nc" id="L194">                System.out.println( &quot;Encryptor.MasterKey=&quot; + ESAPI.encoder().encodeForBase64(raw, false) );</span>
<span class="nc" id="L195">                System.out.println( &quot;Encryptor.MasterSalt=&quot; + ESAPI.encoder().encodeForBase64(salt, false) );</span>
<span class="nc" id="L196">                System.out.println( &quot;#==============================================================&quot; + eol);</span>
<span class="nc" id="L197">    }</span>
	
    
    /**
     * Private CTOR for {@code JavaEncryptor}, called by {@code getInstance()}.
     * @throws EncryptionException if can't construct this object for some reason.
     * 					Original exception will be attached as the 'cause'.
     */
<span class="nc" id="L205">    private JavaEncryptor() throws EncryptionException {</span>
<span class="nc" id="L206">        byte[] salt = ESAPI.securityConfiguration().getMasterSalt();</span>
<span class="nc" id="L207">        byte[] skey = ESAPI.securityConfiguration().getMasterKey();</span>

<span class="nc bnc" id="L209" title="All 4 branches missed.">        assert salt != null : &quot;Can't obtain master salt, Encryptor.MasterSalt&quot;;</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">        assert salt.length &gt;= 16 : &quot;Encryptor.MasterSalt must be at least 16 bytes. &quot; +</span>
                                   &quot;Length is: &quot; + salt.length + &quot; bytes.&quot;;
<span class="nc bnc" id="L212" title="All 4 branches missed.">        assert skey != null : &quot;Can't obtain master key, Encryptor.MasterKey&quot;;</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">        assert skey.length &gt;= 7 : &quot;Encryptor.MasterKey must be at least 7 bytes. &quot; +</span>
                                  &quot;Length is: &quot; + skey.length + &quot; bytes.&quot;;
        
        // Set up secretKeySpec for use for symmetric encryption and decryption,
        // and set up the public/private keys for asymmetric encryption /
        // decryption.
        // TODO: Note: If we dump ESAPI 1.4 crypto backward compatibility,
        //       then we probably will ditch the Encryptor.EncryptionAlgorithm
        //       property. If so, encryptAlgorithm should probably use
        //       Encryptor.CipherTransformation and just pull off the cipher
        //       algorithm name so we can use it here.
<span class="nc" id="L224">        synchronized(JavaEncryptor.class) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if ( ! initialized ) {</span>
                //
                // For symmetric encryption
                //
                //      NOTE: FindBugs complains about this
                //            (ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD) but
                //            it should be OK since it is synchronized and only
                //            done once. While we could separate this out and
                //            handle in a static initializer, it just seems to
                //            fit better here.
<span class="nc" id="L235">                secretKeySpec = new SecretKeySpec(skey, encryptAlgorithm );</span>
                
                //
                // For asymmetric encryption (i.e., public/private key)
                //
                try {
<span class="nc" id="L241">                    SecureRandom prng = SecureRandom.getInstance(randomAlgorithm);</span>

                    // Because hash() is not static (but it could be were in not
                    // for the interface method specification in Encryptor), we
                    // cannot do this initialization in a static method or static
                    // initializer.
<span class="nc" id="L247">                    byte[] seed = hash(new String(skey, encoding),new String(salt, encoding)).getBytes(encoding);</span>
<span class="nc" id="L248">                    prng.setSeed(seed);</span>
<span class="nc" id="L249">                    initKeyPair(prng);</span>
<span class="nc" id="L250">                } catch (Exception e) {</span>
<span class="nc" id="L251">                    throw new EncryptionException(&quot;Encryption failure&quot;, &quot;Error creating Encryptor&quot;, e);</span>
<span class="nc" id="L252">                }             </span>
                
                // Mark everything as initialized.
<span class="nc" id="L255">                initialized = true;</span>
            }
<span class="nc" id="L257">        }</span>
<span class="nc" id="L258">    }</span>
     


	/**
     * {@inheritDoc}
     * 
	 * Hashes the data with the supplied salt and the number of iterations specified in
	 * the ESAPI SecurityConfiguration.
	 */
	public String hash(String plaintext, String salt) throws EncryptionException {
<span class="nc" id="L269">		return hash( plaintext, salt, hashIterations );</span>
	}
	
	/**
     * {@inheritDoc}
     * 
	 * Hashes the data using the specified algorithm and the Java MessageDigest class. This method
	 * first adds the salt, a separator (&quot;:&quot;), and the data, and then rehashes the specified number of iterations
	 * in order to help strengthen weak passwords.
	 */
	public String hash(String plaintext, String salt, int iterations) throws EncryptionException {
<span class="nc" id="L280">		byte[] bytes = null;</span>
		try {
<span class="nc" id="L282">			MessageDigest digest = MessageDigest.getInstance(hashAlgorithm);</span>
<span class="nc" id="L283">			digest.reset();</span>
<span class="nc" id="L284">			digest.update(ESAPI.securityConfiguration().getMasterSalt());</span>
<span class="nc" id="L285">			digest.update(salt.getBytes(encoding));</span>
<span class="nc" id="L286">			digest.update(plaintext.getBytes(encoding));</span>

			// rehash a number of times to help strengthen weak passwords
<span class="nc" id="L289">			bytes = digest.digest();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">			for (int i = 0; i &lt; iterations; i++) {</span>
<span class="nc" id="L291">				digest.reset();</span>
<span class="nc" id="L292">				bytes = digest.digest(bytes);</span>
			}
<span class="nc" id="L294">			String encoded = ESAPI.encoder().encodeForBase64(bytes,false);</span>
<span class="nc" id="L295">			return encoded;</span>
<span class="nc" id="L296">		} catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L297">			throw new EncryptionException(&quot;Internal error&quot;, &quot;Can't find hash algorithm &quot; + hashAlgorithm, e);</span>
<span class="nc" id="L298">		} catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L299">			throw new EncryptionException(&quot;Internal error&quot;, &quot;Can't find encoding for &quot; + encoding, ex);</span>
		}
	}

	/**
	* {@inheritDoc}
	*/
	 public CipherText encrypt(PlainText plaintext) throws EncryptionException {
		 // Now more of a convenience function for using the master key.
<span class="nc" id="L308">		 return encrypt(secretKeySpec, plaintext);</span>
	 }
	 
	 /**
	  * {@inheritDoc}
	  */
	 public CipherText encrypt(SecretKey key, PlainText plain)
	 			throws EncryptionException
	 {
<span class="nc bnc" id="L317" title="All 2 branches missed.">		 if ( key == null ) {</span>
<span class="nc" id="L318">			 throw new IllegalArgumentException(&quot;(Master) encryption key arg may not be null. Is Encryptor.MasterKey set?&quot;);</span>
		 }
<span class="nc bnc" id="L320" title="All 2 branches missed.">		 if ( plain == null ) {</span>
<span class="nc" id="L321">			 throw new IllegalArgumentException(&quot;PlainText may arg not be null&quot;);</span>
		 }
<span class="nc" id="L323">		 byte[] plaintext = plain.asBytes();</span>
<span class="nc" id="L324">		 boolean overwritePlaintext = ESAPI.securityConfiguration().overwritePlainText();</span>

<span class="nc" id="L326">		 boolean success = false;	// Used in 'finally' clause.</span>
<span class="nc" id="L327">		 String xform = null;</span>
<span class="nc" id="L328">		 int keySize = key.getEncoded().length * 8;	// Convert to # bits</span>

		try {
<span class="nc" id="L331">			 xform = ESAPI.securityConfiguration().getCipherTransformation();</span>
<span class="nc" id="L332">             String[] parts = xform.split(&quot;/&quot;);</span>
<span class="nc bnc" id="L333" title="All 4 branches missed.">             assert parts.length == 3 : &quot;Malformed cipher transformation: &quot; + xform;</span>
<span class="nc" id="L334">             String cipherMode = parts[1];</span>
             
             // This way we can prevent modes like OFB and CFB where the IV should never
             // be repeated with the same encryption key (at least until we support
             // Encryptor.ChooseIVMethod=specified and allow us to specify some mechanism
             // to ensure the IV will never be repeated (such as a time stamp or other
             // monotonically increasing function).
             // DISCUSS: Should we include the permitted cipher modes in the exception msg?
<span class="nc bnc" id="L342" title="All 2 branches missed.">             if ( ! CryptoHelper.isAllowedCipherMode(cipherMode) ) {</span>
<span class="nc" id="L343">                 throw new EncryptionException(&quot;Encryption failure: invalid cipher mode ( &quot; + cipherMode + &quot;) for encryption&quot;,</span>
                             &quot;Encryption failure: Cipher transformation &quot; + xform + &quot; specifies invalid &quot; +
                             &quot;cipher mode &quot; + cipherMode);
             }
             
			 // Note - Cipher is not thread-safe so we create one locally
			 //        Also, we need to change this eventually so other algorithms can
			 //        be supported. Eventually, there will be an encrypt() method that
			 //        takes a (new class) CryptoControls, as something like this:
			 //          public CipherText encrypt(CryptoControls ctrl, SecretKey skey, PlainText plaintext)
			 //        and this method will just call that one.
<span class="nc" id="L354">			 Cipher encrypter = Cipher.getInstance(xform);</span>
<span class="nc" id="L355">			 String cipherAlg = encrypter.getAlgorithm();</span>
<span class="nc" id="L356">			 int keyLen = ESAPI.securityConfiguration().getEncryptionKeyLength();</span>

			 // DISCUSS: OK, what do we want to do here if keyLen != keySize? If use keyLen, encryption
			 //		     could fail with an exception, but perhaps that's what we want. Or we may just be
			 //			 OK with silently using keySize as long as keySize &gt;= keyLen, which then interprets
			 //			 ESAPI.EncryptionKeyLength as the *minimum* key size, but as long as we have something
			 //			 stronger it's OK to use it. For now, I am just going to log warning if different, but use
			 //			 keySize unless keySize is SMALLER than ESAPI.EncryptionKeyLength, in which case I'm going
			 //			 to log an error.
			 //
			 //			 IMPORTANT NOTE:	When we generate key sizes for both DES and DESede the result of
			 //								SecretKey.getEncoding().length includes the TRUE key size (i.e.,
			 //								*with* the even parity bits) rather than the EFFECTIVE key size
			 //								(which incidentally is what KeyGenerator.init() expects for DES
			 //								and DESede; duh! Nothing like being consistent). This leads to
			 //								the following dilemma:
			 //
			 //													EFFECTIVE Key Size		TRUE Key Size
			 //													(KeyGenerator.init())	(SecretKey.getEncoding().length)
			 //									========================================================================
			 //									For DES:			56 bits					64 bits
			 //									For DESede:			112 bits / 168 bits		192 bits (always)
			 //
			 //								We are trying to automatically determine the key size from SecretKey
			 //								based on 8 * SecretKey.getEncoding().length, but as you can see, the
			 //								2 key 3DES and the 3 key 3DES both use the same key size (192 bits)
			 //								regardless of what is passed to KeyGenerator.init(). There are no advertised
			 //								methods to get the key size specified by the init() method so I'm not sure how
			 //								this is actually working internally. However, it does present a problem if we
			 //								wish to communicate the 3DES key size to a recipient for later decryption as
			 //								they would not be able to distinguish 2 key 3DES from 3 key 3DES.
			 //
			 //								The only workaround I know is to pass the explicit key size down. However, if
			 //								we are going to do that, I'd propose passing in a CipherSpec object so we could
			 //								tell what cipher transformation to use as well instead of just the key size. Then
			 //								we would extract keySize from the CipherSpec object of from the SecretKey object.
			 //
<span class="nc bnc" id="L393" title="All 2 branches missed.">			 if ( keySize != keyLen ) {</span>
				 // DISCUSS: Technically this is not a security &quot;failure&quot; per se, but not really a &quot;success&quot; either.
<span class="nc" id="L395">				 logger.warning(Logger.SECURITY_FAILURE, &quot;Encryption key length mismatch. ESAPI.EncryptionKeyLength is &quot; +</span>
						 keyLen + &quot; bits, but length of actual encryption key is &quot; + keySize +
				 		&quot; bits.  Did you remember to regenerate your master key (if that is what you are using)???&quot;);
			 }
			 // DISCUSS: Reconsider these warnings. If thousands of encryptions are done in tight loop, no one needs
			 //          more than 1 warning. Should we do something more intelligent here?
<span class="nc bnc" id="L401" title="All 2 branches missed.">			 if ( keySize &lt; keyLen ) {</span>
				 // ESAPI.EncryptionKeyLength defaults to 128, but that means that we could not use DES (as weak as it
				 // is), even for legacy code. Therefore, this has been changed to simple log a warning rather than
				 //	throw the following exception.
				 //				 throw new ConfigurationException(&quot;Actual key size of &quot; + keySize + &quot; bits smaller than specified &quot; +
				 //						  &quot;encryption key length (ESAPI.EncryptionKeyLength) of &quot; + keyLen + &quot; bits.&quot;);
<span class="nc" id="L407">				 logger.warning(Logger.SECURITY_FAILURE, &quot;Actual key size of &quot; + keySize + &quot; bits SMALLER THAN specified &quot; +</span>
						 &quot;encryption key length (ESAPI.EncryptionKeyLength) of &quot; + keyLen + &quot; bits with cipher algorithm &quot; + cipherAlg);
			 }
<span class="nc bnc" id="L410" title="All 2 branches missed.">			 if ( keySize &lt; 112 ) {		// NIST Special Pub 800-57 considers 112-bits to be the minimally safe key size from 2010-2030.</span>
				 						// Note that 112 bits 'just happens' to be size of 2-key Triple DES!
<span class="nc" id="L412">				 logger.warning(Logger.SECURITY_FAILURE, &quot;Potentially unsecure encryption. Key size of &quot; + keySize + &quot;bits &quot; +</span>
				                &quot;not sufficiently long for &quot; + cipherAlg + &quot;. Should use appropriate algorithm with key size &quot; +
				                &quot;of *at least* 112 bits except when required by legacy apps. See NIST Special Pub 800-57.&quot;);
			 }
			 // Check if algorithm mentioned in SecretKey is same as that being used for Cipher object.
			 // They should be the same. If they are different, things could fail. (E.g., DES and DESede
			 // require keys with even parity. Even if key was sufficient size, if it didn't have the correct
			 // parity it could fail.)
			 //
<span class="nc" id="L421">			 String skeyAlg = key.getAlgorithm();</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">			 if ( !( cipherAlg.startsWith( skeyAlg + &quot;/&quot; ) || cipherAlg.equals( skeyAlg ) ) ) {</span>
				 // DISCUSS: Should we thrown a ConfigurationException here or just log a warning??? I'm game for
				 //			 either, but personally I'd prefer the squeaky wheel to the annoying throwing of
				 //			 a ConfigurationException (which is a RuntimeException). Less likely to upset
				 //			 the development community.
<span class="nc" id="L427">				 logger.warning(Logger.SECURITY_FAILURE, &quot;Encryption mismatch between cipher algorithm (&quot; +</span>
						 cipherAlg + &quot;) and SecretKey algorithm (&quot; + skeyAlg + &quot;). Cipher will use algorithm &quot; + cipherAlg);
			 }

<span class="nc" id="L431">			 byte[] ivBytes = null;</span>
<span class="nc" id="L432">			 CipherSpec cipherSpec = new CipherSpec(encrypter, keySize);	// Could pass the ACTUAL (intended) key size</span>
			 
             // Using cipher mode that supports *both* confidentiality *and* authenticity? If so, then
             // use the specified SecretKey as-is rather than computing a derived key from it. We also
             // don't expect a separate MAC in the specified CipherText object so therefore don't try
             // to validate it.
<span class="nc" id="L438">             boolean preferredCipherMode = CryptoHelper.isCombinedCipherMode( cipherMode );</span>
<span class="nc" id="L439">             SecretKey encKey = null;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">			 if ( preferredCipherMode ) {</span>
<span class="nc" id="L441">			     encKey = key;</span>
			 } else {
<span class="nc" id="L443">			     encKey = computeDerivedKey(KeyDerivationFunction.kdfVersion, getDefaultPRF(),</span>
			    		 				    key, keySize, &quot;encryption&quot;);
			 }
			 
<span class="nc bnc" id="L447" title="All 2 branches missed.">			 if ( cipherSpec.requiresIV() ) {</span>
<span class="nc" id="L448">				 String ivType = ESAPI.securityConfiguration().getIVType();</span>
<span class="nc" id="L449">				 IvParameterSpec ivSpec = null;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">				 if ( ivType.equalsIgnoreCase(&quot;random&quot;) ) {</span>
<span class="nc" id="L451">					 ivBytes = ESAPI.randomizer().getRandomBytes(encrypter.getBlockSize());</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">				 } else if ( ivType.equalsIgnoreCase(&quot;fixed&quot;) ) {</span>
<span class="nc" id="L453">					 String fixedIVAsHex = ESAPI.securityConfiguration().getFixedIV();</span>
<span class="nc" id="L454">					 ivBytes = Hex.decode(fixedIVAsHex);</span>
					 /* FUTURE		 } else if ( ivType.equalsIgnoreCase(&quot;specified&quot;)) {
					 		// FUTURE - TODO  - Create instance of specified class to use for IV generation and
					 		//					 use it to create the ivBytes. (The intent is to make sure that
					 		//				     1) IVs are never repeated for cipher modes like OFB and CFB, and
					 		//					 2) to screen for weak IVs for the particular cipher algorithm.
					 		//		In meantime, use 'random' for block cipher in feedback mode. Unlikely they will
					 		//		be repeated unless you are salting SecureRandom with same value each time. Anything
					 		//		monotonically increasing should be suitable, like a counter, but need to remember
					 		//		it across JVM restarts. Was thinking of using System.currentTimeMillis(). While
					 		//		it's not perfect it probably is good enough. Could even all (advanced) developers
					 		//      to define their own class to create a unique IV to allow them some choice, but
					 		//      definitely need to provide a safe, default implementation.
					  */
<span class="nc" id="L468">				 } else {</span>
					 // TODO: Update to add 'specified' once that is supported and added above.
<span class="nc" id="L470">					 throw new ConfigurationException(&quot;Property Encryptor.ChooseIVMethod must be set to 'random' or 'fixed'&quot;);</span>
				 }
<span class="nc" id="L472">				 ivSpec = new IvParameterSpec(ivBytes);</span>
<span class="nc" id="L473">				 cipherSpec.setIV(ivBytes);</span>
<span class="nc" id="L474">				 encrypter.init(Cipher.ENCRYPT_MODE, encKey, ivSpec);</span>
<span class="nc" id="L475">			 } else {</span>
<span class="nc" id="L476">				 encrypter.init(Cipher.ENCRYPT_MODE, encKey);</span>
			 }
<span class="nc" id="L478">			 logger.debug(Logger.EVENT_SUCCESS, &quot;Encrypting with &quot; + cipherSpec);</span>
<span class="nc" id="L479">			 byte[] raw = encrypter.doFinal(plaintext);</span>
                 // Convert to CipherText.
<span class="nc" id="L481">             CipherText ciphertext = new CipherText(cipherSpec, raw);</span>
			 
			 // If we are using a &quot;preferred&quot; cipher mode--i.e., one that supports *both* confidentiality and
			 // authenticity, there is no point to store a separate MAC in the CipherText object. Thus we only
             // do this when we are not using such a cipher mode.
<span class="nc bnc" id="L486" title="All 2 branches missed.">			 if ( !preferredCipherMode ) {</span>
			     // Compute derived key, and then use it to compute and store separate MAC in CipherText object.
<span class="nc" id="L488">			     SecretKey authKey = computeDerivedKey(KeyDerivationFunction.kdfVersion, getDefaultPRF(),</span>
			    		 							   key, keySize, &quot;authenticity&quot;);
<span class="nc" id="L490">			     ciphertext.computeAndStoreMAC(  authKey );</span>
			 }
<span class="nc" id="L492">			 logger.debug(Logger.EVENT_SUCCESS, &quot;JavaEncryptor.encrypt(SecretKey,byte[],boolean,boolean) -- success!&quot;);</span>
<span class="nc" id="L493">			 success = true;	// W00t!!!</span>
<span class="nc" id="L494">			 return ciphertext;</span>
<span class="nc" id="L495">		} catch (InvalidKeyException ike) {</span>
<span class="nc" id="L496">			 throw new EncryptionException(&quot;Encryption failure: Invalid key exception.&quot;,</span>
					 &quot;Requested key size: &quot; + keySize + &quot;bits greater than 128 bits. Must install unlimited strength crypto extension from Sun: &quot; +
<span class="nc" id="L498">					 ike.getMessage(), ike);</span>
<span class="nc" id="L499">		 } catch (ConfigurationException cex) {</span>
<span class="nc" id="L500">			 throw new EncryptionException(&quot;Encryption failure: Configuration error. Details in log.&quot;, &quot;Key size mismatch or unsupported IV method. &quot; +</span>
					 &quot;Check encryption key size vs. ESAPI.EncryptionKeyLength or Encryptor.ChooseIVMethod property.&quot;, cex);
<span class="nc" id="L502">		 } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L503">			 throw new EncryptionException(&quot;Encryption failure (invalid IV)&quot;,</span>
<span class="nc" id="L504">					 &quot;Encryption problem: Invalid IV spec: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L505">		 } catch (IllegalBlockSizeException e) {</span>
<span class="nc" id="L506">			 throw new EncryptionException(&quot;Encryption failure (no padding used; invalid input size)&quot;,</span>
<span class="nc" id="L507">					 &quot;Encryption problem: Invalid input size without padding (&quot; + xform + &quot;). &quot; + e.getMessage(), e);</span>
<span class="nc" id="L508">		 } catch (BadPaddingException e) {</span>
<span class="nc" id="L509">			 throw new EncryptionException(&quot;Encryption failure&quot;,</span>
<span class="nc" id="L510">					 &quot;[Note: Should NEVER happen in encryption mode.] Encryption problem: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L511">		 } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L512">			 throw new EncryptionException(&quot;Encryption failure (unavailable cipher requested)&quot;,</span>
<span class="nc" id="L513">					 &quot;Encryption problem: specified algorithm in cipher xform &quot; + xform + &quot; not available: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L514">		 } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L515">			 throw new EncryptionException(&quot;Encryption failure (unavailable padding scheme requested)&quot;,</span>
<span class="nc" id="L516">					 &quot;Encryption problem: specified padding scheme in cipher xform &quot; + xform + &quot; not available: &quot; + e.getMessage(), e);</span>
		 } finally {
			 // Don't overwrite anything in the case of exceptions because they may wish to retry.
<span class="nc bnc" id="L519" title="All 8 branches missed.">			 if ( success &amp;&amp; overwritePlaintext ) {</span>
<span class="nc" id="L520">				 plain.overwrite();		// Note: Same as overwriting 'plaintext' byte array.</span>
		}
<span class="nc" id="L522">	}</span>
	 }

	/**
	* {@inheritDoc}
	*/
	public PlainText decrypt(CipherText ciphertext) throws EncryptionException {
		 // Now more of a convenience function for using the master key.
<span class="nc" id="L530">		 return decrypt(secretKeySpec, ciphertext);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	public PlainText decrypt(SecretKey key, CipherText ciphertext)
	    throws EncryptionException, IllegalArgumentException
	{
<span class="nc" id="L539">	    long start = System.nanoTime();  // Current time in nanosecs; used to prevent timing attacks</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">	    if ( key == null ) {</span>
<span class="nc" id="L541">	        throw new IllegalArgumentException(&quot;SecretKey arg may not be null&quot;);</span>
	    }
<span class="nc bnc" id="L543" title="All 2 branches missed.">	    if ( ciphertext == null ) {</span>
<span class="nc" id="L544">	        throw new IllegalArgumentException(&quot;Ciphertext may arg not be null&quot;);</span>
	    }

<span class="nc bnc" id="L547" title="All 2 branches missed.">	    if ( ! CryptoHelper.isAllowedCipherMode(ciphertext.getCipherMode()) ) {</span>
	        // This really should be an illegal argument exception, but it could
	        // mean that a partner encrypted something using a cipher mode that
	        // you do not accept, so it's a bit more complex than that. Also
	        // throwing an IllegalArgumentException doesn't allow us to provide
	        // the two separate error messages or automatically log it.
<span class="nc" id="L553">	        throw new EncryptionException(DECRYPTION_FAILED,</span>
<span class="nc" id="L554">	                &quot;Invalid cipher mode &quot; + ciphertext.getCipherMode() +</span>
	        &quot; not permitted for decryption or encryption operations.&quot;);
	    }
<span class="nc" id="L557">	    logger.debug(Logger.EVENT_SUCCESS,</span>
	            &quot;Args valid for JavaEncryptor.decrypt(SecretKey,CipherText): &quot; +
	            ciphertext);

<span class="nc" id="L561">	    PlainText plaintext = null;</span>
<span class="nc" id="L562">	    boolean caughtException = false;</span>
<span class="nc" id="L563">	    int progressMark = 0;</span>
	    try {
	        // First we validate the MAC.
<span class="nc" id="L566">	        boolean valid = CryptoHelper.isCipherTextMACvalid(key, ciphertext);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">	        if ( !valid ) {</span>
	            try {
	                // This is going to fail, but we want the same processing
	                // to occur as much as possible so as to prevent timing
	                // attacks. We _could_ just be satisfied by the additional
	                // sleep in the 'finally' clause, but an attacker on the
	                // same server who can run something like 'ps' can tell
	                // CPU time versus when the process is sleeping. Hence we
	                // try to make this as close as possible. Since we know
	                // it is going to fail, we ignore the result and ignore
	                // the (expected) exception.
<span class="nc" id="L578">	                handleDecryption(key, ciphertext); // Ignore return (should fail).</span>
<span class="nc" id="L579">	            } catch(Exception ex) {</span>
	                ;   // Ignore
<span class="nc" id="L581">	            }</span>
<span class="nc" id="L582">	            throw new EncryptionException(DECRYPTION_FAILED,</span>
	                    &quot;Decryption failed because MAC invalid for &quot; +
	                    ciphertext);
	        }
<span class="nc" id="L586">	        progressMark++;</span>
	        // The decryption only counts if the MAC was valid.
<span class="nc" id="L588">	        plaintext = handleDecryption(key, ciphertext);</span>
<span class="nc" id="L589">	        progressMark++;</span>
<span class="nc" id="L590">	    } catch(EncryptionException ex) {</span>
<span class="nc" id="L591">	        caughtException = true;</span>
<span class="nc" id="L592">	        String logMsg = null;</span>
<span class="nc bnc" id="L593" title="All 3 branches missed.">	        switch( progressMark ) {</span>
	        case 1:
<span class="nc" id="L595">	            logMsg = &quot;Decryption failed because MAC invalid. See logged exception for details.&quot;;</span>
<span class="nc" id="L596">	            break;</span>
	        case 2:
<span class="nc" id="L598">	            logMsg = &quot;Decryption failed because handleDecryption() failed. See logged exception for details.&quot;;</span>
<span class="nc" id="L599">	            break;</span>
	        default:
<span class="nc" id="L601">	            logMsg = &quot;Programming error: unexpected progress mark == &quot; + progressMark;</span>
	        break;
	        }
<span class="nc" id="L604">	        logger.error(Logger.SECURITY_FAILURE, logMsg);</span>
<span class="nc" id="L605">	        throw ex;           // Re-throw</span>
	    }
	    finally {
<span class="nc bnc" id="L608" title="All 4 branches missed.">	        if ( caughtException ) {</span>
	            // The rest of this code is to try to account for any minute differences
	            // in the time it might take for the various reasons that decryption fails
	            // in order to prevent any other possible timing attacks. Perhaps it is
	            // going overboard. If nothing else, if N_SECS is large enough, it might
	            // deter attempted repeated attacks by making them take much longer.
<span class="nc" id="L614">	            long now = System.nanoTime();</span>
<span class="nc" id="L615">	            long elapsed = now - start;</span>
<span class="nc" id="L616">	            final long NANOSECS_IN_SEC = 1000000000L; // nanosec is 10**-9 sec</span>
<span class="nc" id="L617">	            long nSecs = N_SECS * NANOSECS_IN_SEC;  // N seconds in nano seconds</span>
<span class="nc bnc" id="L618" title="All 4 branches missed.">	            if ( elapsed &lt; nSecs ) {</span>
	                // Want to sleep so total time taken is N seconds.
<span class="nc" id="L620">	                long extraSleep = nSecs - elapsed;</span>

	                // 'extraSleep' is in nanoseconds. Need to convert to a millisec
	                // part and nanosec part. Nanosec is 10**-9, millsec is
	                // 10**-3, so divide by (10**-9 / 10**-3), or 10**6 to
	                // convert to from nanoseconds to milliseconds.
<span class="nc" id="L626">	                long millis = extraSleep / 1000000L;</span>
<span class="nc" id="L627">	                long nanos  = (extraSleep - (millis * 1000000L));</span>
<span class="nc bnc" id="L628" title="All 12 branches missed.">	                assert nanos &gt;= 0 &amp;&amp; nanos &lt;= Integer.MAX_VALUE :</span>
                            &quot;Nanosecs out of bounds; nanos = &quot; + nanos;
	                try {
<span class="nc" id="L631">	                    Thread.sleep(millis, (int)nanos);</span>
<span class="nc" id="L632">	                } catch(InterruptedException ex) {</span>
	                    ;   // Ignore
<span class="nc" id="L634">	                }</span>
	            } // Else ... time already exceeds N_SECS sec, so do not sleep.
<span class="nc" id="L636">	        }</span>
<span class="nc" id="L637">	    }</span>
<span class="nc" id="L638">	    return plaintext;</span>
	}

    // Handle the actual decryption portion. At this point it is assumed that
    // any MAC has already been validated. (But see &quot;DISCUSS&quot; issue, below.)
    private PlainText handleDecryption(SecretKey key, CipherText ciphertext)
        throws EncryptionException
    {
<span class="nc" id="L646">        int keySize = 0;</span>
        try {
<span class="nc" id="L648">            Cipher decrypter = Cipher.getInstance(ciphertext.getCipherTransformation());</span>
<span class="nc" id="L649">            keySize = key.getEncoded().length * 8;  // Convert to # bits</span>

            // Using cipher mode that supports *both* confidentiality *and* authenticity? If so, then
            // use the specified SecretKey as-is rather than computing a derived key from it. We also
            // don't expect a separate MAC in the specified CipherText object so therefore don't try
            // to validate it.
<span class="nc" id="L655">            boolean preferredCipherMode = CryptoHelper.isCombinedCipherMode( ciphertext.getCipherMode() );</span>
<span class="nc" id="L656">            SecretKey encKey = null;</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">            if ( preferredCipherMode ) {</span>
<span class="nc" id="L658">                encKey = key;</span>
            } else {
                // TODO: PERFORMANCE: Calculate avg time this takes and consider caching for very short interval
                //       (e.g., 2 to 5 sec tops). Otherwise doing lots of encryptions in a loop could take a LOT longer.
                //       But remember Jon Bentley's &quot;Rule #1 on performance: First make it right, then make it fast.&quot;
            	//		 This would be a security trade-off as it would leave keys in memory a bit longer, so it
            	//		 should probably be off by default and controlled via a property.
            	//
            	// TODO: Feed in some additional parms here to use as the 'context' for the
            	//		 KeyDerivationFunction...especially the KDF version. We would have to
            	//		 store that in the CipherText object. We *possibly* could make it
            	//		 transient so it would not be serialized with the CipherText object,
            	//		 otherwise we would have to implement readObject() and writeObject()
            	//		 methods there to support backward compatibility. Anyhow the intent
            	//		 is to prevent down grade attacks when we finally re-design and
            	//		 re-implement the MAC. Think about this in version 2.1.1.
<span class="nc" id="L674">                encKey = computeDerivedKey( ciphertext.getKDFVersion(), ciphertext.getKDF_PRF(),</span>
                		                    key, keySize, &quot;encryption&quot;);
            }
<span class="nc bnc" id="L677" title="All 2 branches missed.">            if ( ciphertext.requiresIV() ) {</span>
<span class="nc" id="L678">                decrypter.init(Cipher.DECRYPT_MODE, encKey, new IvParameterSpec(ciphertext.getIV()));</span>
            } else {
<span class="nc" id="L680">                decrypter.init(Cipher.DECRYPT_MODE, encKey);</span>
            }
<span class="nc" id="L682">            byte[] output = decrypter.doFinal(ciphertext.getRawCipherText());</span>
<span class="nc" id="L683">            return new PlainText(output);</span>

<span class="nc" id="L685">        } catch (InvalidKeyException ike) {</span>
<span class="nc" id="L686">            throw new EncryptionException(DECRYPTION_FAILED, &quot;Must install JCE Unlimited Strength Jurisdiction Policy Files from Sun&quot;, ike);</span>
<span class="nc" id="L687">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L688">            throw new EncryptionException(DECRYPTION_FAILED, &quot;Invalid algorithm for available JCE providers - &quot; +</span>
<span class="nc" id="L689">                    ciphertext.getCipherTransformation() + &quot;: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L690">        } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L691">            throw new EncryptionException(DECRYPTION_FAILED, &quot;Invalid padding scheme (&quot; +</span>
<span class="nc" id="L692">                    ciphertext.getPaddingScheme() + &quot;) for cipher transformation &quot; + ciphertext.getCipherTransformation() +</span>
<span class="nc" id="L693">                    &quot;: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L694">        } catch (InvalidAlgorithmParameterException e) {</span>
<span class="nc" id="L695">            throw new EncryptionException(DECRYPTION_FAILED, &quot;Decryption problem: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L696">        } catch (IllegalBlockSizeException e) {</span>
<span class="nc" id="L697">            throw new EncryptionException(DECRYPTION_FAILED, &quot;Decryption problem: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L698">        } catch (BadPaddingException e) {</span>
            //DISCUSS: This needs fixed. Already validated MAC in CryptoHelper.isCipherTextMACvalid() above.
            //So only way we could get a padding exception is if invalid padding were used originally by
            //the party doing the encryption. (This might happen with a buggy padding scheme for instance.)
            //It *seems* harmless though, so will leave it for now, and technically, we need to either catch it
            //or declare it in a throws class. Clearly we don't want to do the later. This should be discussed
            //during a code inspection.
            SecretKey authKey;
            try {
<span class="nc" id="L707">                authKey = computeDerivedKey( ciphertext.getKDFVersion(), ciphertext.getKDF_PRF(),</span>
                		                     key, keySize, &quot;authenticity&quot;);
<span class="nc" id="L709">            } catch (Exception e1) {</span>
<span class="nc" id="L710">                throw new EncryptionException(DECRYPTION_FAILED,</span>
<span class="nc" id="L711">                        &quot;Decryption problem -- failed to compute derived key for authenticity: &quot; + e1.getMessage(), e1);</span>
<span class="nc" id="L712">            }</span>
<span class="nc" id="L713">            boolean success = ciphertext.validateMAC( authKey );</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if ( success ) {</span>
<span class="nc" id="L715">                throw new EncryptionException(DECRYPTION_FAILED, &quot;Decryption problem: &quot; + e.getMessage(), e);</span>
            } else {
<span class="nc" id="L717">                throw new EncryptionException(DECRYPTION_FAILED,</span>
                        &quot;Decryption problem: WARNING: Adversary may have tampered with &quot; +
<span class="nc" id="L719">                        &quot;CipherText object orCipherText object mangled in transit: &quot; + e.getMessage(), e);</span>
            }
        }
    }
	
	/**
	* {@inheritDoc}
	*/
	public String sign(String data) throws EncryptionException {
		try {
<span class="nc" id="L729">			Signature signer = Signature.getInstance(signatureAlgorithm);</span>
<span class="nc" id="L730">			signer.initSign(privateKey);</span>
<span class="nc" id="L731">			signer.update(data.getBytes(encoding));</span>
<span class="nc" id="L732">			byte[] bytes = signer.sign();</span>
<span class="nc" id="L733">			return ESAPI.encoder().encodeForBase64(bytes, false);</span>
<span class="nc" id="L734">		} catch (InvalidKeyException ike) {</span>
<span class="nc" id="L735">			throw new EncryptionException(&quot;Encryption failure&quot;, &quot;Must install unlimited strength crypto extension from Sun&quot;, ike);</span>
<span class="nc" id="L736">		} catch (Exception e) {</span>
<span class="nc" id="L737">			throw new EncryptionException(&quot;Signature failure&quot;, &quot;Can't find signature algorithm &quot; + signatureAlgorithm, e);</span>
		}
	}
		
	/**
	* {@inheritDoc}
	*/
	public boolean verifySignature(String signature, String data) {
		try {
<span class="nc" id="L746">			byte[] bytes = ESAPI.encoder().decodeFromBase64(signature);</span>
<span class="nc" id="L747">			Signature signer = Signature.getInstance(signatureAlgorithm);</span>
<span class="nc" id="L748">			signer.initVerify(publicKey);</span>
<span class="nc" id="L749">			signer.update(data.getBytes(encoding));</span>
<span class="nc" id="L750">			return signer.verify(bytes);</span>
<span class="nc" id="L751">		} catch (Exception e) {</span>
		    // NOTE: EncryptionException constructed *only* for side-effect of causing logging.
		    // FindBugs complains about this and since it examines byte-code, there's no way to
		    // shut it up.
<span class="nc" id="L755">			new EncryptionException(&quot;Invalid signature&quot;, &quot;Problem verifying signature: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L756">			return false;</span>
		}
	}

	/**
	* {@inheritDoc}
     *
     * @param expiration
     * @throws IntegrityException
     */
	public String seal(String data, long expiration) throws IntegrityException {
<span class="nc bnc" id="L767" title="All 2 branches missed.">	    if ( data == null ) {</span>
<span class="nc" id="L768">	        throw new IllegalArgumentException(&quot;Data to be sealed may not be null.&quot;);</span>
	    }
	    
		try {
<span class="nc" id="L772">		    String b64data = null;</span>
            try {
<span class="nc" id="L774">                b64data = ESAPI.encoder().encodeForBase64(data.getBytes(&quot;UTF-8&quot;), false);</span>
<span class="nc" id="L775">            } catch (UnsupportedEncodingException e) {</span>
                ; // Ignore; should never happen since UTF-8 built into rt.jar
<span class="nc" id="L777">            }</span>
			// mix in some random data so even identical data and timestamp produces different seals
<span class="nc" id="L779">			String nonce = ESAPI.randomizer().getRandomString(10, EncoderConstants.CHAR_ALPHANUMERICS);</span>
<span class="nc" id="L780">			String plaintext = expiration + &quot;:&quot; + nonce + &quot;:&quot; + b64data;</span>
			// add integrity check; signature is already base64 encoded.
<span class="nc" id="L782">			String sig = this.sign( plaintext );</span>
<span class="nc" id="L783">			CipherText ciphertext = this.encrypt( new PlainText(plaintext + &quot;:&quot; + sig) );</span>
<span class="nc" id="L784">			String sealedData = ESAPI.encoder().encodeForBase64(ciphertext.asPortableSerializedByteArray(), false);</span>
<span class="nc" id="L785">			return sealedData;</span>
<span class="nc" id="L786">		} catch( EncryptionException e ) {</span>
<span class="nc" id="L787">			throw new IntegrityException( e.getUserMessage(), e.getLogMessage(), e );</span>
		}
	}

	/**
	* {@inheritDoc}
	*/
	public String unseal(String seal) throws EncryptionException {
<span class="nc" id="L795">		PlainText plaintext = null;</span>
		try {
<span class="nc" id="L797">		    byte[] encryptedBytes = ESAPI.encoder().decodeFromBase64(seal);</span>
<span class="nc" id="L798">		    CipherText cipherText = null;</span>
		    try {
<span class="nc" id="L800">		        cipherText = CipherText.fromPortableSerializedBytes(encryptedBytes);</span>
<span class="nc" id="L801">		    } catch( AssertionError e) {</span>
	            // Some of the tests in EncryptorTest.testVerifySeal() are examples of
		        // this if assertions are enabled.
<span class="nc" id="L804">		        throw new EncryptionException(&quot;Invalid seal&quot;,</span>
	                                          &quot;Seal passed garbarge data resulting in AssertionError: &quot; + e);
<span class="nc" id="L806">	        }</span>
<span class="nc" id="L807">			plaintext = this.decrypt(cipherText);</span>

<span class="nc" id="L809">			String[] parts = plaintext.toString().split(&quot;:&quot;);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">			if (parts.length != 4) {</span>
<span class="nc" id="L811">				throw new EncryptionException(&quot;Invalid seal&quot;, &quot;Seal was not formatted properly.&quot;);</span>
			}
	
<span class="nc" id="L814">			String timestring = parts[0];</span>
<span class="nc" id="L815">			long now = new Date().getTime();</span>
<span class="nc" id="L816">			long expiration = Long.parseLong(timestring);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">			if (now &gt; expiration) {</span>
<span class="nc" id="L818">				throw new EncryptionException(&quot;Invalid seal&quot;, &quot;Seal expiration date of &quot; + new Date(expiration) + &quot; has past.&quot;);</span>
			}
<span class="nc" id="L820">			String nonce = parts[1];</span>
<span class="nc" id="L821">			String b64data = parts[2];</span>
<span class="nc" id="L822">			String sig = parts[3];</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">			if (!this.verifySignature(sig, timestring + &quot;:&quot; + nonce + &quot;:&quot; + b64data ) ) {</span>
<span class="nc" id="L824">				throw new EncryptionException(&quot;Invalid seal&quot;, &quot;Seal integrity check failed&quot;);</span>
			}	
<span class="nc" id="L826">			return new String(ESAPI.encoder().decodeFromBase64(b64data), &quot;UTF-8&quot;);</span>
<span class="nc" id="L827">		} catch (EncryptionException e) {</span>
<span class="nc" id="L828">			throw e;</span>
<span class="nc" id="L829">		} catch (Exception e) {</span>
<span class="nc" id="L830">			throw new EncryptionException(&quot;Invalid seal&quot;, &quot;Invalid seal:&quot; + e.getMessage(), e);</span>
		}
	}

	
	/**
	* {@inheritDoc}
	*/
	public boolean verifySeal( String seal ) {
		try {
<span class="nc" id="L840">			unseal( seal );</span>
<span class="nc" id="L841">			return true;</span>
<span class="nc" id="L842">		} catch( EncryptionException e ) {</span>
<span class="nc" id="L843">			return false;</span>
		}
	}
	
	/**
	* {@inheritDoc}
	*/
	public long getTimeStamp() {
<span class="nc" id="L851">		return new Date().getTime();</span>
	}

	/**
	* {@inheritDoc}
	*/
	public long getRelativeTimeStamp( long offset ) {
<span class="nc" id="L858">		return new Date().getTime() + offset;</span>
	}

	// DISCUSS: Why experimental? Would have to be added to Encryptor interface
	//			but only 3 things I saw wrong with this was 1) it used HMacMD5 instead
	//			of HMacSHA1 (see discussion below), 2) that the HMac key is the
	//			same one used for encryption (also see comments), and 3) it caught
	//			overly broad exceptions. Here it is with these specific areas
	//			addressed, but no unit testing has been done at this point. -kww
   /**
    * Compute an HMAC for a String.  Experimental.
    * @param input	The input for which to compute the HMac.
    */
/********************
	public String computeHMAC( String input ) throws EncryptionException {
		try {
			Mac hmac = Mac.getInstance(&quot;HMacSHA1&quot;); // DISCUSS: Changed to HMacSHA1. MD5 *badly* broken
												   //          SHA1 should really be avoided, but using
												   //		   for HMAC-SHA1 is acceptable for now. Plan
												   //		   to migrate to SHA-256 or NIST replacement for
												   //		   SHA1 in not too distant future.
			// DISCUSS: Also not recommended that the HMac key is the same as the one
			//			used for encryption (namely, Encryptor.MasterKey). If anything it
			//			would be better to use Encryptor.MasterSalt for the HMac key, or
			//			perhaps a derived key based on the master salt. (One could use
			//			KeyDerivationFunction.computeDerivedKey().)
			//
			byte[] salt = ESAPI.securityConfiguration().getMasterSalt();
			hmac.init( new SecretKeySpec(salt, &quot;HMacSHA1&quot;) );	// Was:	hmac.init(secretKeySpec)	
			byte[] inBytes;
			try {
				inBytes = input.getBytes(&quot;UTF-8&quot;);
			} catch (UnsupportedEncodingException e) {
				logger.warning(Logger.SECURITY_FAILURE, &quot;computeHMAC(): Can't find UTF-8 encoding; using default encoding&quot;, e);
				inBytes = input.getBytes();
			}
			byte[] bytes = hmac.doFinal( inBytes );
			return ESAPI.encoder().encodeForBase64(bytes, false);
		} catch (InvalidKeyException ike) {
			throw new EncryptionException(&quot;Encryption failure&quot;, &quot;Must install unlimited strength crypto extension from Sun&quot;, ike);
	    } catch (NoSuchAlgorithmException e) {
	    	throw new EncryptionException(&quot;Could not compute HMAC&quot;, &quot;Can't find HMacSHA1 algorithm. &quot; +
	    															&quot;Problem computing HMAC for &quot; + input, e );
	    }
	}
********************/

    /**
     * Log a security warning every Nth time one of the deprecated encrypt or
     * decrypt methods are called. ('N' is hard-coded to be 25 by default, but
     * may be changed via the system property
     * {@code ESAPI.Encryptor.warnEveryNthUse}.) In other words, we nag
     * them until the give in and change it. ;-)
     * 
     * @param where The string &quot;encrypt&quot; or &quot;decrypt&quot;, corresponding to the
     *              method that is being logged.
     * @param msg   The message to log.
     */
    private void logWarning(String where, String msg) {
<span class="nc" id="L917">        int counter = 0;</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">        if ( where.equals(&quot;encrypt&quot;) ) {</span>
<span class="nc" id="L919">            counter = encryptCounter++;</span>
<span class="nc" id="L920">            where = &quot;JavaEncryptor.encrypt(): [count=&quot; + counter +&quot;]&quot;;</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">        } else if ( where.equals(&quot;decrypt&quot;) ) {</span>
<span class="nc" id="L922">            counter = decryptCounter++;</span>
<span class="nc" id="L923">            where = &quot;JavaEncryptor.decrypt(): [count=&quot; + counter +&quot;]&quot;;</span>
        } else {
<span class="nc" id="L925">            where = &quot;JavaEncryptor: Unknown method: &quot;;</span>
        }
        // We log the very first time (note the use of post-increment on the
        // counters) and then every Nth time thereafter. Logging every single
        // time is likely to be way too much logging.
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if ( (counter % logEveryNthUse) == 0 ) {</span>
<span class="nc" id="L931">            logger.warning(Logger.SECURITY_FAILURE, where + msg);</span>
        }
<span class="nc" id="L933">    }</span>
    
    private KeyDerivationFunction.PRF_ALGORITHMS getPRF(String name) {    	
<span class="nc" id="L936">		String prfName = null;</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">		if ( name == null ) {</span>
<span class="nc" id="L938">			prfName = ESAPI.securityConfiguration().getKDFPseudoRandomFunction();</span>
		} else {
<span class="nc" id="L940">			prfName = name;</span>
		}
<span class="nc" id="L942">		KeyDerivationFunction.PRF_ALGORITHMS prf = KeyDerivationFunction.convertNameToPRF(prfName);</span>
<span class="nc" id="L943">		return prf;</span>
    }
    
    private KeyDerivationFunction.PRF_ALGORITHMS getDefaultPRF() {
<span class="nc" id="L947">		String prfName = ESAPI.securityConfiguration().getKDFPseudoRandomFunction();</span>
<span class="nc" id="L948">		return getPRF(prfName);</span>
    }
    
    // Private interface to call ESAPI's KDF to get key for encryption or authenticity.
    private SecretKey computeDerivedKey(int kdfVersion, KeyDerivationFunction.PRF_ALGORITHMS prf,
    									SecretKey kdk, int keySize, String purpose)
    	throws NoSuchAlgorithmException, InvalidKeyException, EncryptionException
    {
    	// These really should be turned into actual runtime checks and an
    	// IllegalArgumentException should be thrown if they are violated.
    	// But this should be OK since this is a private method. Also, this method will
    	// be called quite often so assertions are a big win as they can be disabled or
    	// enabled at will.
<span class="nc bnc" id="L961" title="All 4 branches missed.">    	assert prf != null : &quot;Pseudo Random Function for KDF cannot be null&quot;;</span>
<span class="nc bnc" id="L962" title="All 4 branches missed.">    	assert kdk != null : &quot;Key derivation key cannot be null.&quot;;</span>
    	// We would choose a larger minimum key size, but we want to be
    	// able to accept DES for legacy encryption needs. NIST says 112-bits is min. If less than that,
    	// we print warning.
<span class="nc bnc" id="L966" title="All 4 branches missed.">    	assert keySize &gt;= 56 : &quot;Key has size of &quot; + keySize + &quot;, which is less than minimum of 56-bits.&quot;;</span>
<span class="nc bnc" id="L967" title="All 4 branches missed.">    	assert (keySize % 8) == 0 : &quot;Key size (&quot; + keySize + &quot;) must be a even multiple of 8-bits.&quot;;</span>
<span class="nc bnc" id="L968" title="All 4 branches missed.">    	assert purpose != null : &quot;Purpose cannot be null. Should be 'encryption' or 'authenticity'.&quot;;</span>
<span class="nc bnc" id="L969" title="All 6 branches missed.">    	assert purpose.equals(&quot;encryption&quot;) || purpose.equals(&quot;authenticity&quot;) :</span>
    		&quot;Purpose must be \&quot;encryption\&quot; or \&quot;authenticity\&quot;.&quot;;

<span class="nc" id="L972">    	KeyDerivationFunction kdf = new KeyDerivationFunction(prf);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">    	if ( kdfVersion != 0 ) {</span>
<span class="nc" id="L974">    		kdf.setVersion(kdfVersion);</span>
    	}
<span class="nc" id="L976">    	return kdf.computeDerivedKey(kdk, keySize, purpose);</span>
    }

    // Get all the algorithms we will be using from ESAPI.properties.
    private static void setupAlgorithms() {
        // setup algorithms
<span class="nc" id="L982">        encryptAlgorithm = ESAPI.securityConfiguration().getEncryptionAlgorithm();</span>
<span class="nc" id="L983">        signatureAlgorithm = ESAPI.securityConfiguration().getDigitalSignatureAlgorithm();</span>
<span class="nc" id="L984">        randomAlgorithm = ESAPI.securityConfiguration().getRandomAlgorithm();</span>
<span class="nc" id="L985">        hashAlgorithm = ESAPI.securityConfiguration().getHashAlgorithm();</span>
<span class="nc" id="L986">        hashIterations = ESAPI.securityConfiguration().getHashIterations();</span>
<span class="nc" id="L987">        encoding = ESAPI.securityConfiguration().getCharacterEncoding();</span>
<span class="nc" id="L988">        encryptionKeyLength = ESAPI.securityConfiguration().getEncryptionKeyLength();</span>
<span class="nc" id="L989">        signatureKeyLength = ESAPI.securityConfiguration().getDigitalSignatureKeyLength();</span>
<span class="nc" id="L990">    }</span>
    
    // Set up signing key pair using the master password and salt. Called (once)
    // from the JavaEncryptor CTOR.
    private static void initKeyPair(SecureRandom prng) throws NoSuchAlgorithmException {
<span class="nc" id="L995">        String sigAlg = signatureAlgorithm.toLowerCase();</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">        if ( sigAlg.endsWith(&quot;withdsa&quot;) ) {</span>
            //
            // Admittedly, this is a kludge. However for Sun JCE, even though
            // &quot;SHA1withDSA&quot; is a valid signature algorithm name, if one calls
            //      KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;SHA1withDSA&quot;);
            // that will throw a NoSuchAlgorithmException with an exception
            // message of &quot;SHA1withDSA KeyPairGenerator not available&quot;. Since
            // SHA1withDSA and DSA keys should be identical, we use &quot;DSA&quot;
            // in the case that SHA1withDSA or SHAwithDSA was specified. This is
            // all just to make these 2 work as expected. Sigh. (Note:
            // this was tested with JDK 1.6.0_21, but likely fails with earlier
            // versions of the JDK as well.)
            //
<span class="nc" id="L1009">            sigAlg = &quot;DSA&quot;;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        } else if ( sigAlg.endsWith(&quot;withrsa&quot;) ) {</span>
            // Ditto for RSA.
<span class="nc" id="L1012">            sigAlg = &quot;RSA&quot;;</span>
        }
<span class="nc" id="L1014">        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(sigAlg);</span>
<span class="nc" id="L1015">        keyGen.initialize(signatureKeyLength, prng);</span>
<span class="nc" id="L1016">        KeyPair pair = keyGen.generateKeyPair();</span>
<span class="nc" id="L1017">        privateKey = pair.getPrivate();</span>
<span class="nc" id="L1018">        publicKey = pair.getPublic();</span>
<span class="nc" id="L1019">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>